<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>webworker fractal</title>
<style id="jsbin-css">
body {
  font-family: sans-serif;
  margin-top: 256px;
}

canvas {
  xborder: 1px solid #AAA;
  display: none;
}

img {
  position: absolute;
}

</style>
</head>
  
  <body>
    <h1>webworker fractal</h1>
    
    <a href="https://github.com/jacksondk/fractal/blob/master/js/fractal.js">fractal code kudus</a><br/>
  <script>
var code = function() {/*
'use strict';

var CPX = {
    add: function(a, b) {
        return {r: a.r + b.r, i: a.i + b.i};
    },
    subtract: function(a, b) {
        return {r: a.r - b.r, i: a.i - b.i};
    },
    multiply: function(a, b) {
        return {r: a.r*b.r - a.i*b.i, i: a.i*b.r + a.r*b.i};
    },
    toString: function(a) {
        return "" + a.r + "+" + a.i + "i";
    },
    abs: function(a) {
        return Math.sqrt(a.r*a.r + a.i*a.i);
    },
    abs2: function(a) {
        return a.r*a.r + a.i*a.i;
    }
};

self.onmessage = function(ev) {
    var o = ev.data;
    var imgData = o.id;
    var w = o.d[0];
    var h = o.d[1];
    var tl = o.tl;
    var br = o.br;
    var maxIter = o.iter;
    postMessage({m: ['start', w, h, tl.i, tl.r, br.i, br.r, maxIter].join(' ') });

    //try {

    var i, row, column;
    var drow = (br.i - tl.i) / h;
    var dcol = (br.r - tl.r) / w;
    var iter;
    for (row = 0; row < h; ++row) {
        for (column = 0; column < w; ++column) {
            var p = {r: tl.r + column*dcol, i: tl.i + row*drow };
            var v = {r: 0, i: 0}
            iter = 0;

            while (CPX.abs2(v) < 4 && iter < maxIter) {
                v = CPX.add( CPX.multiply(v, v), p);
                iter++;
            }
            
            if (iter > 255) { iter %= 255; }

            var index = (row*w + column) * 4;
            imgData.data[index+0] = iter % 255;
            imgData.data[index+1] = iter % 255;
            imgData.data[index+2] = iter % 255;
            imgData.data[index+3] = 255;
        }
    }

    //} catch(ex) { console.error(ex); }

    postMessage({id:imgData, m:'end', index:o.index, ir:o.ir, ii:o.ii, d:o.d});
};
*/}.toString()
    .replace(/^[^\/]+\/\*!?/, '')
    .replace(/\*\/[^\/]+$/,   '');



var log = function(m) {
    document.body.insertAdjacentHTML('beforeend', ['<div>', m, '</div>'].join(''));
};

var QS = function(sel) {
    return document.querySelector(sel);
};

var createWorker = function(code) {
    window.URL = window.URL || window.webkitURL;
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
    var blob;
    try {
        blob = new Blob([code], {type:'application/javascript'});
    } catch (e) {
        blob = new BlobBuilder(); blob.append(code); blob = blob.getBlob();
    }
    return new Worker(URL.createObjectURL(blob));
};

var createCanvas = function(dims) {
  var cvsEl = document.createElement('canvas');
  cvsEl.width  = dims[0];
  cvsEl.height = dims[1];
  document.body.appendChild(cvsEl);
  return cvsEl;
};



var cfg = {
  jobId: 123,            // just for reference back to the server
  d:    [256*3, 256*2],  // image size in px
  tl:   {r:-2, i: 1},   // top left fractal pos
  br:   {r: 1, i:-1},   // bottom right fractal pos
  iter: 256,             // maximum iteration steps
  parts: [4, 4],        // divide work into 4 2x2 parts
  index: 0             // you're worker 1/4
};



var divideWork = function(cfg) {
    var dr = (cfg.br.r - cfg.tl.r) / cfg.parts[0];
    var di = (cfg.br.i - cfg.tl.i) / cfg.parts[1];
    var ir =    cfg.index % cfg.parts[0];
    var ii = ~~(cfg.index / cfg.parts[0]);
  
    var pl = {
        d:     [cfg.d[0]/cfg.parts[0], cfg.d[1]/cfg.parts[1]],
        tl:    {r: cfg.tl.r +  ir   *dr, i: cfg.tl.i +  ii    *di},
        br:    {r: cfg.tl.r + (ir+1)*dr, i: cfg.tl.i + (ii+1)*di},
        iter:  cfg.iter,
        ir:    ir, // for joining the work back
        ii:    ii,
        index: cfg.index
    };
    //console.log(pl);
    return pl;
};


var steps = cfg.parts[0] * cfg.parts[1];
var yetToComplete = steps;
log('workers: ' + yetToComplete);

var addWorker = function(index) {
    cfg.index = index;
    var payload = divideWork(cfg);
    var worker = createWorker(code);
    
    // worker aux resources
    var cvsEl = createCanvas(payload.d);
    var ctx = cvsEl.getContext('2d');
    var imgData = ctx.createImageData(payload.d[0], payload.d[1]);
    payload.id = imgData;

    worker.onmessage = function(ev) { // webworker I/O
        var o = ev.data;
        //if (o.m) { log(o.m); }
      
        if (o.id) { // imageData returned
            ctx.putImageData(o.id, 0, 0);
            var b64Result = cvsEl.toDataURL('image/jpeg');

            if (1) { // show computed image (optional)
                var imgEl = document.createElement('img');
                imgEl.src = b64Result;
                var s = imgEl.style;
                s.left = (o.ir*o.d[0])+'px';
                s.top  = (o.ii*o.d[1])+'px';
                document.body.appendChild(imgEl);
            }
            
            // free worker resources
            worker.terminate();
            document.body.removeChild(cvsEl);
            cvsEl = undefined; imgData = undefined; ctx = undefined; delete o.id; delete o.m;
            
            if (0) {
                o.resultImg = b64Result;
                o.jobId = cfg.jobId;
                console.log('SENDING BACK TO SERVER...', o);
            }
            
            // could send result back now, logging instead
            --yetToComplete;
            log('#' + o.index + ' done, left:' + yetToComplete);
            if (yetToComplete === 0) {
                log('DONE!');
            }
        }
    };
    worker.postMessage(payload);
};

for (var i = 0, I = steps; i < I; ++i) { // spawn the workers!
  addWorker(i);
}
</script>
</body>
</html>
